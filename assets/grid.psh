#include "BasicStructures.fxh"
#include "../src/grid.fxh"


cbuffer cbCameraAttribs
{
    CameraAttribs g_CameraAttribs;
}

cbuffer cbGridAttribs
{
    GridAttribs g_GridAttribs;
}

struct PSInput
{
    float4 ClipPos : SV_POSITION;
    float2 tile_pos : WORLD_POS1;
    float2 grid_pos : WORLD_POS2;
    float2 camera_grid_pos : WORLD_POS3;
    float3 view_dir : WORLD_POS4;
    
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
     // UV is grid space coordinate of pixel
    float2 uv = PSIn.grid_pos;
        // Find screen space derivates in grid space. 
    float2 dudv = float2(length(float2(ddx(uv.x), ddy(uv.x))), length(float2(ddx(uv.y), ddy(uv.y))));

        // Define minimum number of pixels between cell lines before LOD switch should occur
    float min_pixels_between_cells = 1.f;
        // User defined grid size, this is the minimum grid cell size in world coordinates. 
    float cs = g_GridAttribs.cell_size;

        // Calc lod-level
    float lod_level = max(0, log10((length(dudv) * min_pixels_between_cells) / cs) + 1);
    float lod_fade = frac(lod_level);

        // Calc cell sizes for lod0, lod1 and lod2
    float lod0_cs = cs * pow(10, floor(lod_level));
    float lod1_cs = lod0_cs * 10.f;
    float lod2_cs = lod1_cs * 10.f;

    bool infinite = g_GridAttribs.infinite == 1 ? true : false;

        // If grid is setup to be infinte, shift uv based on camera position in local tile space
    uv += infinite ? PSIn.camera_grid_pos : float2(0, 0);

        // Allow each anti-aliased line to cover up to 2 pixels.
    dudv *= 2;
        // Offset to pixel center.
    uv = abs(uv) + dudv / 2;

        // Calculate distance to cell line center for each lod and pick max of X,Y to get a coverage alpha value
        // Note: another alternative is to average the x,y values and use that as the covergae alpha (dot(lod0_cross_a, 0.5))
    float2 lod0_cross_a = 1.f - abs(saturate(fmod(uv, lod0_cs) / dudv) * 2 - 1.f);
    float lod0_a = max(lod0_cross_a.x, lod0_cross_a.y);
    float2 lod1_cross_a = 1.f - abs(saturate(fmod(uv, lod1_cs) / dudv) * 2 - 1.f);
    float lod1_a = max(lod1_cross_a.x, lod1_cross_a.y);
    float2 lod2_cross_a = 1.f - abs(saturate(fmod(uv, lod2_cs) / dudv) * 2 - 1.f);
    float lod2_a = max(lod2_cross_a.x, lod2_cross_a.y);

    float4 thin_color = g_GridAttribs.thin_lines_color;
    float4 thick_color = g_GridAttribs.thick_lines_color;

    // Set XZ axis colors for axis-matching thick lines
    const float2 displaced_grid_pos = PSIn.grid_pos + (infinite ? PSIn.camera_grid_pos : float2(0, 0));
    const bool is_axis_z = lod2_cross_a.x > 0 && (-cs < displaced_grid_pos.x && displaced_grid_pos.x < cs);
    const bool is_axis_x = lod2_cross_a.y > 0 && (-cs < displaced_grid_pos.y && displaced_grid_pos.y < cs);
    thick_color = is_axis_x ? g_GridAttribs.origin_axis_x_color : thick_color;
    thick_color = is_axis_z ? g_GridAttribs.origin_axis_z_color : thick_color;

    // Blend between falloff colors.
    float4 c = lod2_a > 0 ? thick_color : lod1_a > 0 ? lerp(thick_color, thin_color, lod_fade) : thin_color;

    // Calculate opacity falloff based on distance to grid extents and gracing angle.
    float3 view_dir = normalize(PSIn.view_dir);
    float op_gracing = 1.f - pow(1.f - abs(dot(view_dir, float3(0, 1, 0))), 10);
    float2 v = infinite ? PSIn.tile_pos + PSIn.grid_pos : PSIn.grid_pos;
    float op_distance = (1.f - saturate(length(v) / g_GridAttribs.grid_extent));
    float op = op_gracing * op_distance;
    //op = op_distance;
    // Blend between LOD level alphas and scale with opacity falloff.
    c.a *= (lod2_a > 0 ? lod2_a : lod1_a > 0 ? lod1_a : (lod0_a * (1 - lod_fade))) * op;
    float4 BaseColor = c;
   // BaseColor.a = 1.0f;
    //float4 BaseColor = g_GridAttribs.origin_axis_x_color;
    
    PSOut.Color = BaseColor;
    

}
