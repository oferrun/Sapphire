

Texture2D g_SceneDepthTexture;
SamplerState g_SceneDepthTexture_sampler;
Texture2D g_SelectionDepthTexture;
SamplerState g_SelectionDepthTexture_sampler;
Texture2D g_SelectionTexture;
SamplerState g_SelectionTexture_sampler;


struct PSInput
{
    float4 Pos   : SV_POSITION;
    float2 UV    : TEX_COORD;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

float linearize_depth(float clip_depth, float near, float far)
{
#if defined(USE_REVERSE_DEPTH)
            return clip_depth == 0.f ? far : (near * far) / (near + clip_depth*(far-near));  
#else    
    return clip_depth == 1.f ? far : (near * far) / (far - clip_depth * (far - near));
#endif
}

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{

    float2 UV = PSIn.UV;
    
    // Generate outline by comparing ID's between current pixel and surrounding pixels.
        // This will collect 4x4 IDs but we will only be using the upper 3x3 taps.        
    float4 id0 = g_SelectionTexture.GatherRed(g_SelectionTexture_sampler, PSIn.UV, int2(-2, -2));
    float4 id1 = g_SelectionTexture.GatherRed(g_SelectionTexture_sampler, PSIn.UV, int2(0, -2));
    float4 id2 = g_SelectionTexture.GatherRed(g_SelectionTexture_sampler, PSIn.UV, int2(-2, 0));
    float4 id3 = g_SelectionTexture.GatherRed(g_SelectionTexture_sampler, PSIn.UV, int2(0, 0));
        // Throw away unused taps and merge into two float4 and a center tap
    id2.xw = id1.xy;
    float id_center = id3.w;
    id3.w = id0.y;
        
        // Count ID misses and average together. a becomes our alpha of the outline.
    static const float avg_scalar = 1.f / 8.f;
    float a = dot(float4(id2 != id_center), avg_scalar);
    a += dot(float4(id3 != id_center), avg_scalar);
    a = saturate(sqrt(a));

        // If alpha is zero, early out.
       
    if (a == 0)
    {
        PSOut.Color = float4(1, 1, 1, a);
        return;
    }

    // To allow outline to bleed over objects and combat TAA jittering artifacts
        // sample depth of selection buffer in a 4x4 neighborhood and pick closest depth.
    float4 dtap0 = g_SelectionDepthTexture.GatherRed(g_SelectionDepthTexture_sampler, PSIn.UV, int2(-2, -2));
    float4 dtap1 = g_SelectionDepthTexture.GatherRed(g_SelectionDepthTexture_sampler, PSIn.UV, int2(0, -2));
    float4 dtap2 = g_SelectionDepthTexture.GatherRed(g_SelectionDepthTexture_sampler, PSIn.UV, int2(-2, 0));
    float4 dtap3 = g_SelectionDepthTexture.GatherRed(g_SelectionDepthTexture_sampler, PSIn.UV, int2(0, 0));
    float d0 = max(dtap0.x, max(dtap0.y, max(dtap0.z, dtap0.w)));
    float d1 = max(dtap1.x, max(dtap1.y, max(dtap1.z, dtap1.w)));
    float d2 = max(dtap2.x, max(dtap2.y, max(dtap2.z, dtap2.w)));
    float d3 = max(dtap3.x, max(dtap3.y, max(dtap3.z, dtap3.w)));
    float d = max(d0, max(d1, max(d2, d3)));

        // Sample scene depth.        
    float scnd = g_SceneDepthTexture.Sample(g_SceneDepthTexture_sampler, PSIn.UV).r;
    

    //float2 near_far = float2(0.1, 100);
    //float seldl = linearize_depth(d, near_far.x, near_far.y);

    //float scndl = linearize_depth(scnd, near_far.x, near_far.y);
        // Compare selection buffer depth with scene depth to determine if outline is behind an object.
    
    bool visible = d <= scnd;

        // If outline is hidden, reduce its alpha value to 30%.
    a *= visible ? 1.f : 0.3f;
    
    PSOut.Color.rgb = float3(1, 1, 0.05);
    //if (d > scnd)
    //    PSOut.Color.rgb = float3(1, 0, 0);
    
    PSOut.Color.a = a;
    

}
